#!/usr/bin/env python3
import asyncio
from grader.tcp import Servidor
import re
Nicks = {}
Canais = {}

# Funções auxiliares

def validarNome(nome):
    # Checa se tem caracteres especiais
    return re.match(br'^[a-zA-Z][a-zA-Z0-9_-]*$', nome) is not None


def sair(conexao):
    # Função para fechar a conexao
    conexao.fechar()

def encontraUsuario(conexao):
    # Retorna o Nick do usuario com base na conexao
    for chave, valor in Nicks.items():
            if conexao == valor:
                return chave
                
    return b'*'

def encontraConexao(usuario):
    # retorna o endereco de conexao do usuario com base no Nick
    for chave, valor in Nicks.items():
            if usuario == chave:
                return valor
                
    return b'*'

def removeDado(dados):
    # Função para retirar comando e quebra de linha de uma mensagem
    if b' ' in dados:
        dados = dados.split(b' ', 1)[1]
    if b'\r\n' in dados:
         dados = dados.split(b'\r\n', 1)[0]
    return dados          



def msgList(conexao, canal, msg):
    # Funcao para mandar msg para todos no canal
    for usuario in Canais[canal.lower()]:
        # Print de descarte
        print('entrando no private msg', msg, '\n*******\n\n\n')
        privateMsg(conexao, usuario, msg)

# Fim das funções auxiliares
#####################
def dadosRecebidos(conexao, dados):
    # Função auxiliar de switch dos comandos de entrada
    if dados == b'':
        return sair(conexao)
    #chamada do tratamento do caso 2
    dados = trataDados(conexao, dados)

    # recebe todos os elementos de dados menos o ultimo (vazio)
    dados = dados[:-1]
    for dado in dados:
        comando = dado.split(b' ', 1)[0] # recebe a primeira palavra da conexao

        if comando == b'PING':
            itsPing(conexao, dado)
        elif comando == b'NICK':
            itsNick(conexao, dado)
        elif comando == b'PRIVMSG':
            destinatario, dest_msg = dado.split(b' :', 1)
            destinatario = destinatario.split(b' ')[1]
            msg = b':' + encontraUsuario(conexao) + b' PRIVMSG ' + destinatario + b' :' + dest_msg
            privateMsg(conexao, destinatario, msg)
        elif comando == b'JOIN':
            entraCanal(conexao, dado)
        #elif comando == b'PART':

        

def conexaoAceita(conexao):
    conexao.registrar_recebedor(dadosRecebidos)
    conexao.dados_residuais = b''

# TRATAMENTO DO CASO 1
def itsPing (conexao, dados):
    # retorna resposta na forma ':server PONG server :dados'
    resposta= b':server PONG server :'
    resposta+= dados.split(b' ', 1)[1] # resposta recebe resposta padrão + payload
    conexao.enviar(resposta)

# TRATAMENTO DO CASO 2
def trataDados(conexao, dados):
    """
    Funcao para o tratamento de entradas, podendo receber entradas como:
    * 'lin', depois 'h' e depois 'a\r\n'
    e as transforma em 'linha\r\n'
    
    normalmente, para a finalização dos dados, entende-se de que o ultimo elemento da lista 
    dados seja o b'' para sair dessa funçao
    
    retorna uma lista
    """
    
    if conexao.dados_residuais != b'':
        dados = conexao.dados_residuais + dados
        conexao.dados_residuais = b''
    
    if b'\n' in dados:
        dados = dados.split(b'\n')
        for i in range(len(dados) - 1):
                dados[i] = dados[i] + b'\n'
        if dados[-1] != b'\n':
            conexao.dados_residuais = dados[-1]
            dados[-1] = b''
    else:
        conexao.dados_residuais = conexao.dados_residuais + dados
        dados = []
    return dados
        
# FIM DO CASO 2	


# TRATAMENTO CASO 3 E 4
def itsNick(conexao, dados):
    # Função para adicionar ou trocar um Nickname para o usuario
    apelido = removeDado(dados)
    apelido_antigo = encontraUsuario(conexao)    


    # validando apelido 
    if validarNome(apelido):
        # se o apelido ja tiver nos nicks e nao tem o mesmo valor de conexao
        if apelido.lower() in Nicks:
            conexao.enviar (b':server 433 ' + apelido_antigo + b' ' + apelido + b' :Nickname is already in use\r\n')
            return 
            
        # Primeiro apelido
        elif apelido.lower() not in Nicks and apelido_antigo == b'*':
            Nicks[apelido.lower()] = conexao
            conexao.enviar(b':server 001 ' + apelido + b' :Welcome\r\n')
            conexao.enviar(b':server 422 ' + apelido + b' :MOTD File is missing\r\n')
            return
        
        # troca de apelido
        else:            
            Nicks[apelido.lower()] = Nicks.pop(apelido_antigo.lower())
            conexao.enviar(b':' + apelido_antigo + b' NICK ' + apelido + b'\r\n')
            return
        
    # apelido invalido          
    else: 
        conexao.enviar(b':server 432 ' + apelido_antigo + b' '+ apelido + b' :Erroneous nickname\r\n')
        return

# INICIO DO 5
def privateMsg(conexao, destinatario, dados):
    # Função para mandar mensagem privada para um determinado usuario

    #Encontrando o nick de quem mandou
    remetente = encontraUsuario(conexao)

    # Caso o destinataio não esteja cadastrado, retorne
    if destinatario.lower() not in Nicks:
         return

    # Encontrando o objeto de conexao do destinatario
    cx_dest = encontraConexao(destinatario.lower())
    
    # enviando a mensagem pro destinatario
    cx_dest.enviar(dados)

    # print de descarte
    print('\n\n*****************\nPRIVATE MSG ENVIO:', dados, '\n*************\n\n\n')

    # Print de descarte
    print("mandou\n\n")

    return  
        
# FIM CASO 5

# CASO 6 e 9 (enviar mensagem com lista de membros quando alguém entra)

def entraCanal(conexao, dados):
    # funcao para entrar no canal

    # Separando o nome do canal
    canal = removeDado(dados)

    # validando o nome do canal
    if (validarNome(canal.split(b'#')[1]) is None) or canal[0] != 35: # 35 eh a cerquilha em ASCII
        conexao.enviar(b':server 403 '  + canal + b' :No such channel\r\n')
        return
    
    # encontrando o nick do usuario que solicitou o canal
    usuario = encontraUsuario(conexao)

    # se o canal nao existe, crie um canal
    if canal.lower() not in Canais:
        Canais[canal.lower()] = [usuario]
    
    # se ele ja existe
    elif canal.lower() in Canais:
        # confirme se o usuario nao esta nesse canal
        # print de descarte
        print('entrando em canal que ja existe')
        if usuario not in Canais[canal.lower()]:
            # print de descarte
            print('Usuario entrando no canal:', usuario)

            # Adicionando o usuario na lista do canal
            var_user = Canais[canal.lower()]
            var_user.append(usuario)
            # Organize os usuarios
            var_user.sort()
            Canais[canal.lower()] = var_user

            # Print de descarte
            print(var_user, '\n\n\n')

            # Deletando a variavel para desalocar espaço na memoria
            del var_user
        else:
            # Caso o usuario esteja no canal
            print('USUARIO DENTRO DO CANAL\n\n\n')
            return

    # enviando msg de entrada no canal
    msg = usuario + b' JOIN :' + canal + b'\r\n'
    
    # mandando a msg
    print('NOME DO CANAL', canal, '\n\n\n\n')
    msgList(conexao, canal, msg)
    print('Canais', Canais)

    # Parte comentada foi escrita pela Bruna, 
    # ainda em fases de teste depois de concluirmos o caso 6
    """
    #parte do teste 9
    #pega os todos o membros daquele canal e coloca em ordem alfabetica
    membrosCanal = Canais[canal]
    membrosCanal.sort()

    #junta em uma variavel separando cada nome por um espaço
    membros = b" ".join(membrosCanal)
    #calcula o limite de caracters que vai poder colocar na tela retirando o que vai de padrão na mensagem já
    x = 512 - len(f':server 353 {usuario} = {canal} :') - len(b'\r\n')

    #padroniza a string de acordo com o n° de caracters que descobrimos que pode ter em cada linha além do prefixo
    membrosPadrao = [membros[i:i+x] for i in range(0, len(membros), x)]

    #envia a mensagem com a lista dos membros para o usuario que entrou
    conexao.enviar(b':server 353 ' + usuario + b' = ' + canal + b' : ' + b" ".join(membrosPadrao) +b'\r\n')
    # envia a mensagem que acabou de exibir os nomes dos membros
    conexao.enviar(b':server 366 '+ usuario + b' '+ canal + b' :End of /NAMES list.')
    """
    return

# CASO 7
def saiCanal(conexao, dados):
    # Função para sair do canal, 
    # ainda em desenvolvimento
    canal = dados.split(b' ', 1)[1] # extraindo o canal após o comando
    canal = canal.split(b'\r\n')[0] # removendo os caracteres de quebra de linha

    usuario = encontraUsuario(conexao)

    # monta a mensagem de aviso para membros do canal
    msg = b':' + usuario + b' PART ' + canal + b'\r\n'

    # envia
    msgList(canal, msg)

    # removendo o usuario do canal
    users = Canais[canal]
    users.remove(usuario)
    Canais[canal] = users
   
servidor = Servidor(6667)
servidor.registrar_monitor_de_conexoes_aceitas(conexaoAceita)
asyncio.get_event_loop().run_forever()
