#!/usr/bin/env python3
import asyncio
from grader.tcp import Servidor
import re
Nicks = {}
Canais = {}



def validar_nome(nome):
    return re.match(br'^[a-zA-Z][a-zA-Z0-9_-]*$', nome) is not None


def sair(conexao):
    print(conexao, 'conexão fechada')
    conexao.fechar()


def dados_recebidos(conexao, dados):
    print('ENTRADA: ', dados)
    if dados == b'':
        return sair(conexao)
    #chamada do tratamento do caso 2
    dados = data_treatment(conexao, dados)
    # recebe todos os elementos de dados menos o ultimo (vazio)
    dados = dados[:-1]
    for dado in dados:
        comando = dado.split(b' ', 1)[0] # recebe a primeira palavra da conexao

        if comando == b'PING':
            itsPing(conexao, dado)
        elif comando == b'NICK':
            itsNick(conexao, dado)
        elif comando == b'PRIVMSG':
            destinatario, dest_msg = dado.split(b' :', 1)
            destinatario = destinatario.split(b' ')[1]
            privatemsg(conexao, destinatario, dest_msg)
        elif comando == b'JOIN':
            print("Entrou no join", dados)
            entraCanal(conexao, dado)
        #elif comando == b'PART':


# TRATAMENTO DO CASO 1
def itsPing (conexao, dados):
    
    resposta= b':server PONG server :'
    resposta+= dados.split(b' ', 1)[1] # resposta recebe resposta padrão + payload
    conexao.enviar(resposta)

def conexao_aceita(conexao):
    print(conexao, 'nova conexão')
    conexao.registrar_recebedor(dados_recebidos)
    conexao.dados_residuais = b''


# TRATAMENTO DO CASO 2
def data_treatment(conexao, dados):
    """
    Funcao para o tratamento de entradas, podendo receber entradas como:
    * 'lin', depois 'h' e depois 'a\r\n'
    e as transforma em 'linha\r\n'
    
    normalmente, para a finalização dos dados, entende-se de que o ultimo elemento da lista 
    dados seja o b'' para sair dessa funçao
    
    retorna uma lista
    """
    
    if conexao.dados_residuais != b'':
        dados = conexao.dados_residuais + dados
        conexao.dados_residuais = b''
    
    if b'\n' in dados:
        dados = dados.split(b'\n')
        for i in range(len(dados) - 1):
                dados[i] = dados[i] + b'\n'
        if dados[-1] != b'\n':
            conexao.dados_residuais = dados[-1]
            dados[-1] = b''
    else:
        conexao.dados_residuais = conexao.dados_residuais + dados
        dados = []
    return dados
        
# FIM DO CASO 2	
# TRATAMENTO CASO 3 E 4


# ENCONTRA USUARIO
def encontra_usuario(conexao):
    # confirmar se existe uma conexao ja estabelecida
        for chave, valor in Nicks.items():
                if conexao == valor:
                    return chave
                    
        return b'*'


def encontraConexao(usuario):
    # confirmar se existe uma conexao ja estabelecida
        for chave, valor in Nicks.items():
                if usuario == chave:
                    return valor
                    
        return b'*'


              
def itsNick(conexao, dados):


    apelido = dados.split(b' ', 1)[1] # extraindo o apelido após o comando
    apelido = apelido.split(b'\r\n')[0] # removendo os caracteres de quebra de linha
    apelido_antigo = encontra_usuario(conexao)    


    # validando apelido 
    if validar_nome(apelido):
        # se o apelido ja tiver nos nicks e nao tem o mesmo valor de conexao
        if apelido.lower() in Nicks:
            conexao.enviar (b':server 433 ' + apelido_antigo + b' ' + apelido + b' :Nickname is already in use\r\n')
            return 
            
        # Primeiro apelido
        elif apelido.lower() not in Nicks and apelido_antigo == b'*':
            Nicks[apelido.lower()] = conexao
            conexao.enviar(b':server 001 ' + apelido + b' :Welcome\r\n')
            conexao.enviar(b':server 422 ' + apelido + b' :MOTD File is missing\r\n')
            return
        
        # troca de apelido
        else:            
            # Print de descarte
            print('NOMES AGORA:', Nicks.keys())
            Nicks[apelido.lower()] = Nicks.pop(apelido_antigo.lower())

            # Print de descarte            
            print('NOMES DEPOIS:', Nicks.keys())

            # Print de descarte
            print("Trocando apelido")
            print('apelido antigo:' , apelido_antigo ,' NICK ' , apelido,'conexao', conexao,  '\n\n')
            
            conexao.enviar(b':' + apelido_antigo + b' NICK ' + apelido + b'\r\n')
            return
        
    # apelido invalido          
    else: 
        conexao.enviar(b':server 432 ' + apelido_antigo + b' '+ apelido + b' :Erroneous nickname\r\n')
        return

# INICIO DO 5
def privatemsg(conexao, destinatario, dados):
    #retirando o comando
    remetente = encontra_usuario(conexao)

    # Print de descarte
    print("destinatario = ", destinatario.lower(), "MENSAGEM = ", dados)
    
    # primeira etapa
    if destinatario.lower() not in Nicks:
         return
    
    cx_dest = encontraConexao(destinatario.lower())

    msg = b':' + remetente + b' PRIVMSG ' + destinatario + b' :' + dados + b'\r\n'
    cx_dest.enviar(msg)

    # Print de descarte
    print("mandou\n\n")

    return  
        
# FIM CASO 5



# CASO 6 e 9 (enviar mensagem com lista de membros quando alguém entra)

# Funcao para mandar msg para todos no canal
def msgList(conexao, canal, msg):
    for usuario in Canais[canal.lower()]:
        # Print de descarte
        print('entrando no private msg')
        privatemsg(conexao, usuario, msg)

    # Print de descarte
    print("MANDANDO MSGS PRA TODOS NO CANAL\n\n*********************\n\n\n")


# funcao para entrar no canal
def entraCanal(conexao, dados):
    # ta entrando aqui
    #print('chegou nessa merda\n\n\n\n')
    # separamento dos dados
    canal = dados.split(b' ', 1)[1] # extraindo o apelido após o comando
    canal = canal.split(b'\r\n')[0] # removendo os caracteres de quebra de linha
    
    # validando o nome do canal
    if (validar_nome(canal.split(b'#')[1]) is None) or canal[0] != 35: # 35 eh a cerquilha em ASCII
        conexao.enviar(b':server 403 '  + canal + b' :No such channel\r\n')

        # Print de descarte
        print('CANAL INVALIDO\n****************\n\n')
        return
    
    print("CANAL VALIDO\n********\n\n\n")

    # encontrando o nick do usuario que solicitou o canal
    usuario = encontra_usuario(conexao)

    # se o canal nao existe, crie um canal
    if canal.lower() not in Canais:

        # Print de descarte
        print('criou canal', canal)
        Canais[canal.lower()] = [usuario]
    # se ele ja existe
    elif canal.lower() in Canais:
        # confirme se o usuario nao esta nesse canal
        if usuario not in Canais[canal.lower()]:
            # Nao estando no canal, coloque-o
            var_user = Canais[canal.lower()]
            var_user.append(usuario)
            # Organize os usuarios
            var_user.sort()
            Canais[canal.lower()] = var_user

            # Print de descarte
            print(var_user, '\n\n\n')

            # Deletando a variavel para desalocar espaço na memoria
            del var_user

    # enviando msg de entrada no canal
    msg = b':' + usuario + b' JOIN :' + canal + b'\r\n'
    
    # mandando a msg
    msgList(conexao, canal, msg)
    print('Canais', Canais)

    #parte do teste 9
    #pega os todos o membros daquele canal e coloca em ordem alfabetica
    membrosCanal = Canais[canal]
    membrosCanal.sort()

    #junta em uma variavel separando cada nome por um espaço
    membros = b" ".join(membrosCanal)
    #calcula o limite de caracters que vai poder colocar na tela retirando o que vai de padrão na mensagem já
    x = 512 - len(f':server 353 {usuario} = {canal} :') - len(b'\r\n')

    #padroniza a string de acordo com o n° de caracters que descobrimos que pode ter em cada linha além do prefixo
    membrosPadrao = [membros[i:i+x] for i in range(0, len(membros), x)]

    #envia a mensagem com a lista dos membros para o usuario que entrou
    conexao.enviar(b':server 353 ' + usuario + b' = ' + canal + b' : ' + b" ".join(membrosPadrao) +b'\r\n')
    # envia a mensagem que acabou de exibir os nomes dos membros
    conexao.enviar(b':server 366 '+ usuario + b' '+ canal + b' :End of /NAMES list.')
    return

# CASO 7
def saiCanal(conexao, dados):
    canal = dados.split(b' ', 1)[1] # extraindo o canal após o comando
    canal = canal.split(b'\r\n')[0] # removendo os caracteres de quebra de linha

    usuario = encontra_usuario(conexao)

    msg = b':' + usuario + b' PART ' + canal + b'\r\n'
    msgList(canal, msg)

    users = Canais[canal]
    users.remove(usuario)
    Canais[canal] = users
   
servidor = Servidor(6667)
servidor.registrar_monitor_de_conexoes_aceitas(conexao_aceita)
asyncio.get_event_loop().run_forever()
